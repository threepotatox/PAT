/*
 * 设计思路：
 * 仅需要输出子序列最长的长度，可按照递增子序列记录长度;
 * * 喜欢的颜色顺序为 {2 3 1 5 6}，遍历 {2 2 4 1 5 5 6 3 1 1 5 6}，
 *     * 当遍历到的颜色为 2，则当前以 2 结尾的子序列最长长度为之前以 2 结尾子序列的最大值加 1，
 *     * 当遍历到的颜色为 3，则当前以 3 结尾的子序列最长长度为之前以 2 或以 3 结尾子序列的最大值加 1，
 *     * 当遍历到的颜色为 1，则当前以 1 结尾的子序列最长长度为之前以 2 或 3 或 1 结尾子序列的最大值加 1，
 *     * ……
 *     * 最终记录到最长子序列长度即为符合条件的最长长度
 * * 程序中具体实现未完全按照上述思路
 *     * 当遍历到的颜色为 2，则以 2 结尾的子序列最长长度加 1，并更新以 3，1，5，6 结尾的子序列最长长度为以 2 结尾或以自身结尾序列的较大值
 *     * 当遍历到的颜色为 3，则以 3 结尾的子序列最长长度加 1，并更新以 1，5，6 结尾的子序列最长长度为以 3 结尾或以自身结尾序列的较大值
 *     * ……
 *     * 最终最大长度直接输出以 6 结尾的子序列长度
 * * 存储过程中按照喜欢颜色的索引值记录
 */

#include <stdio.h>

int main(void)
{
	int map[201], a[10001], dp[201] = {0};
	int n, m, l, color, count = 0;
	int i, j;

	scanf("%d %d", &n, &m);
	for (i = 1; i <= m; i++) {
		scanf("%d", &color);
		map[color] = i;
	}
	scanf("%d", &l);
	for (i = 0; i < l; i++) {
		scanf("%d", &color);
		if (map[color] > 0) {
			a[count] = map[color];
			count++;
		}
	}

	for (i = 0; i < count; i++) {
		color = a[i];
		dp[color]++;
		for (j = color + 1; j <= m && dp[j] < dp[color]; j++) {
			dp[j] = dp[color];
		}
	}

	printf("%d", dp[m]);

	return 0;
}
